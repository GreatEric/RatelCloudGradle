import { __decorate, __awaiter, __generator, __metadata, __param } from 'tslib';
import { CommonModule } from '@angular/common';
import { Injectable, EventEmitter, Inject, forwardRef, ViewChild, ElementRef, Input, Output, Component, NgModule } from '@angular/core';
import domtoimage from 'dom-to-image';
import * as jq from 'jquery';

var ToolboxDefaultOptions = /** @class */ (function () {
    function ToolboxDefaultOptions() {
        this.filename = 'screenshot.png';
        this.cancelText = 'Cancel';
        this.downloadText = 'Download';
    }
    ToolboxDefaultOptions = __decorate([
        Injectable()
    ], ToolboxDefaultOptions);
    return ToolboxDefaultOptions;
}());
var Colors = /** @class */ (function () {
    function Colors() {
        this.gray = '#898b89';
        this.lightGray = '#e6e3e3';
    }
    Colors = __decorate([
        Injectable()
    ], Colors);
    return Colors;
}());
var HightLevelZindex = /** @class */ (function () {
    function HightLevelZindex() {
        this.top = 1;
        this.second = 0;
    }
    HightLevelZindex = __decorate([
        Injectable()
    ], HightLevelZindex);
    return HightLevelZindex;
}());

'use strict';
var DOMProcess = /** @class */ (function () {
    function DOMProcess() {
        this.domURL = window.URL;
        this.imageType = 'image/png';
    }
    DOMProcess.prototype.appendToBody = function (element) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                document.body.appendChild(element);
                return [2 /*return*/, element];
            });
        });
    };
    DOMProcess.prototype.canvasToImage = function (canvas) {
        return __awaiter(this, void 0, void 0, function () {
            var url;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        url = canvas.toDataURL(this.imageType);
                        return [4 /*yield*/, this.dataUrlToImage(url)];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    DOMProcess.prototype.clearCanvasRect = function (canvas) {
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
    };
    DOMProcess.prototype.dataUrlToImage = function (url) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var image = new Image();
                        image.onload = function () {
                            resolve(image);
                        };
                        image.onerror = reject;
                        image.src = url;
                    })];
            });
        });
    };
    DOMProcess.prototype.clipImageToCanvas = function (image, clipStartX, clipStartY, clipWidth, clipHeight) {
        return __awaiter(this, void 0, void 0, function () {
            var canvas, context;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.createCanvas(Math.abs(clipWidth), Math.abs(clipHeight))];
                    case 1:
                        canvas = _a.sent();
                        context = canvas.getContext('2d');
                        context.drawImage(image, clipStartX, clipStartY, clipWidth, clipHeight, 0, 0, canvas.width, canvas.height);
                        this.remove(image);
                        return [2 /*return*/, canvas];
                }
            });
        });
    };
    DOMProcess.prototype.createCanvas = function (width, height) {
        return __awaiter(this, void 0, void 0, function () {
            var canvas;
            return __generator(this, function (_a) {
                canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                return [2 /*return*/, canvas];
            });
        });
    };
    DOMProcess.prototype.downloadByUrl = function (url, filename) {
        var downloadLink = document.createElement('a');
        downloadLink.href = url;
        downloadLink.download = filename;
        downloadLink.target = '_blank';
        downloadLink.click();
        downloadLink.remove();
        this.domURL.revokeObjectURL(url);
    };
    DOMProcess.prototype.downloadCanvas = function (canvas, filename) {
        return __awaiter(this, void 0, void 0, function () {
            var downloadUrl;
            return __generator(this, function (_a) {
                downloadUrl = canvas.toDataURL(this.imageType);
                this.downloadByUrl(downloadUrl, filename);
                return [2 /*return*/, canvas];
            });
        });
    };
    DOMProcess.prototype.getStyle = function (element, property) {
        var styles = window.getComputedStyle(element);
        return styles[property];
    };
    DOMProcess.prototype.remove = function (element) {
        if (element) {
            element.remove();
        }
        element = null;
    };
    DOMProcess.prototype.isTransparent = function (element) {
        var backgroundColor = window.getComputedStyle(element).backgroundColor;
        return backgroundColor === 'transparent' || backgroundColor === '' || backgroundColor === 'rgba(0, 0, 0, 0)';
    };
    DOMProcess.prototype.listenInteractiveCanvas = function (canvas, rectBackground, mouseupListener, mousedownListener, contextmenuListener) {
        return __awaiter(this, void 0, void 0, function () {
            var context, rect, dragging, draw, mousedown, mousemove, mouseup, contextmenu, touchStart, touched, touchMove;
            return __generator(this, function (_a) {
                context = canvas.getContext('2d');
                rect = {
                    startX: 0,
                    startY: 0,
                    w: 0,
                    h: 0
                };
                dragging = false;
                draw = function () {
                    context.beginPath();
                    context.fillStyle = rectBackground;
                    context.fillRect(rect.startX, rect.startY, rect.w, rect.h);
                    context.closePath();
                };
                mousedown = function (e) {
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    rect.startX = e.pageX - canvas.offsetLeft;
                    rect.startY = e.pageY - canvas.offsetTop;
                    mousedownListener(rect);
                    rect.w = 0;
                    rect.h = 0;
                    dragging = true;
                };
                mousemove = function (e) {
                    if (dragging) {
                        rect.w = e.pageX - canvas.offsetLeft - rect.startX;
                        rect.h = e.pageY - canvas.offsetTop - rect.startY;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        draw();
                    }
                };
                mouseup = function () {
                    dragging = false;
                    mouseupListener(canvas, rect);
                };
                contextmenu = function (e) {
                    contextmenuListener();
                    e.preventDefault();
                    return false;
                };
                touchStart = function (e) {
                    e.preventDefault();
                    var touch = e.changedTouches[0];
                    var mouseEvent = new MouseEvent('mousedown', {
                        clientX: touch.pageX,
                        clientY: touch.pageY
                    });
                    canvas.dispatchEvent(mouseEvent);
                };
                touched = function () {
                    var mouseEvent = new MouseEvent('mouseup', {});
                    canvas.dispatchEvent(mouseEvent);
                };
                touchMove = function (e) {
                    e.preventDefault();
                    var touch = e.changedTouches[0];
                    var mouseEvent = new MouseEvent('mousemove', {
                        clientX: touch.pageX,
                        clientY: touch.pageY
                    });
                    canvas.dispatchEvent(mouseEvent);
                };
                canvas.addEventListener('mousedown', mousedown, false);
                canvas.addEventListener('mouseup', mouseup, false);
                canvas.addEventListener('mousemove', mousemove, false);
                canvas.addEventListener('touchstart', touchStart, false);
                canvas.addEventListener('touchend', touched, false);
                canvas.addEventListener('touchmove', touchMove, false);
                canvas.addEventListener('contextmenu', contextmenu, false);
                document.body.addEventListener('touchmove', function (event) { return event.preventDefault(); }, false);
                return [2 /*return*/, canvas];
            });
        });
    };
    DOMProcess.prototype.setCanvasStyle = function (canvas, left, top, background, zIndex) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                canvas.style.cursor = 'crosshair';
                canvas.style.position = 'absolute';
                canvas.style.left = left + 'px';
                canvas.style.top = top + 'px';
                canvas.style.background = background;
                canvas.style.zIndex = zIndex;
                canvas.style.opacity = '0.5';
                return [2 /*return*/, canvas];
            });
        });
    };
    DOMProcess.prototype.setToolboxPositionStyle = function (toolboxElement, left, top) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                toolboxElement.style.left = left + 'px';
                toolboxElement.style.top = top + 'px';
                return [2 /*return*/, toolboxElement];
            });
        });
    };
    DOMProcess.prototype.setToolboxStackStyle = function (toolboxElement, zIndex) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                toolboxElement.style.position = 'absolute';
                toolboxElement.style.zIndex = zIndex;
                return [2 /*return*/, toolboxElement];
            });
        });
    };
    DOMProcess = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [])
    ], DOMProcess);
    return DOMProcess;
}());

var $ = jq;
/**
 * Capture dom setion with indicate element
 */
var ScreenshotComponent = /** @class */ (function () {
    function ScreenshotComponent(colors, hightLevelZindex, defaultOptions, domprocess) {
        var _this = this;
        this.colors = colors;
        this.hightLevelZindex = hightLevelZindex;
        this.defaultOptions = defaultOptions;
        this.domprocess = domprocess;
        this.isOpenChange = new EventEmitter();
        this.api = new EventEmitter();
        this.showToolbox = false;
        this.cancelText = 'Cancel';
        this.downloadText = 'Download';
        this.filename = 'screenshot.png';
        this.toolboxMargin = 5;
        this.calculateToolboxPosition = function (offsetLeft, offsetTop, rect, toolboxWidth, toolboxHeight) {
            var left = offsetLeft + rect.startX + rect.w;
            var top = offsetTop + rect.startY + rect.h;
            if (rect.w >= 0) {
                left -= toolboxWidth;
            }
            if (rect.h >= 0) {
                top += _this.toolboxMargin;
            }
            else {
                top = top - toolboxHeight - _this.toolboxMargin;
            }
            return {
                left: left,
                top: top
            };
        };
        this.cancel = function () {
            _this.showToolbox = false;
            _this.domprocess.clearCanvasRect(_this.interactiveCanvas);
        };
        this.download = function () {
            _this.isOpenChange.emit(false);
            window.setTimeout(function () {
                var elementSelector = _this.getElementSelector();
                var element = elementSelector[0];
                var options = _this.getOptions(element);
                domtoimage
                    .toPng(element, options)
                    .then(_this.domprocess.dataUrlToImage)
                    .then(function (image) {
                    _this.domprocess.remove(image);
                    return _this.domprocess.clipImageToCanvas(image, _this.rect.startX, _this.rect.startY, _this.rect.w, _this.rect.h);
                })
                    .then(function (canvas) { return _this.domprocess.downloadCanvas(canvas, _this.toolboxOptions.filename); })
                    .then(_this.domprocess.remove)
                    .catch(function (error) { return console.error(error); });
            });
        };
        this.downloadFull = function () {
            _this.isOpenChange.emit(false);
            window.setTimeout(function () {
                var elementSelector = _this.getElementSelector();
                var element = elementSelector[0];
                var options = _this.getOptions(element);
                domtoimage
                    .toPng(element, options)
                    .then(function (imageUrl) { return _this.domprocess.downloadByUrl(imageUrl, _this.toolboxOptions.filename); })
                    .catch(function (error) { return console.error(error); });
            });
        };
        this.findMaxZindex = function () {
            var zMax = 0;
            $('body *').each(function () {
                var zIndexStr = $(this).css('zIndex');
                var zIndex = parseInt(zIndexStr, 10);
                if (zIndex && zIndex > zMax) {
                    zMax = zIndex;
                }
            });
            return zMax;
        };
        this.getElementSelector = function () {
            return _this.target
                ? $(_this.target)
                : $(_this.container.nativeElement).filter(function (index, element) {
                    var elementName = element.tagName.toLowerCase();
                    return elementName !== 'screenshot-toolbox';
                });
        };
        this.getOptions = function (element) {
            var boudingClientRect = element.getBoundingClientRect();
            var options = {
                width: boudingClientRect.width,
                height: boudingClientRect.height
            };
            if (_this.domprocess.isTransparent(element)) {
                var parentBackgroundColor = _this.domprocess.getStyle(element, 'backgroundColor');
                options = Object.assign({}, options, { bgcolor: parentBackgroundColor });
            }
            return options;
        };
        this.setHightLevelZindex = function () {
            var maxZindex = _this.findMaxZindex();
            _this.hightLevelZindex.second = maxZindex + 1;
            _this.hightLevelZindex.top = _this.hightLevelZindex.second + 1;
        };
        this.toPng = function (callback) {
            return new Promise(function (resolve, reject) {
                _this.isOpenChange.emit(false);
                window.setTimeout(function () {
                    var elementSelector = _this.getElementSelector();
                    var element = elementSelector[0];
                    var options = _this.getOptions(element);
                    return domtoimage
                        .toPng(element, options)
                        .then(_this.domprocess.dataUrlToImage)
                        .then(function (image) {
                        _this.domprocess.remove(image);
                        return _this.domprocess.clipImageToCanvas(image, _this.rect.startX, _this.rect.startY, _this.rect.w, _this.rect.h);
                    })
                        .then(function (canvas) {
                        var url = canvas.toDataURL('image/png');
                        if (callback) {
                            callback(url);
                        }
                        resolve(url);
                    })
                        .catch(function (error) {
                        console.error(error);
                        reject(error);
                    });
                });
            });
        };
        this.canvasMousedownListener = function () {
            _this.showToolbox = false;
        };
        this.canvasMouseupListener = function (canvas, rect) {
            if (rect.w !== 0 && rect.h !== 0) {
                // this.showToolbox = false;
                _this.rect = rect;
                var toolbox = $(_this.container.nativeElement).find('ng2-screenshot-toolbox');
                console.log(toolbox.outerWidth());
                // console.log(toolbox.width())
                // // const toolbox = $('ng2-screenshot-toolbox');
                var toolboxElement = toolbox.get(0);
                console.log(toolboxElement.clientWidth);
                console.log(_this.hightLevelZindex);
                /**
                 * toolbox position setting
                 * because read elememt's width sould indicated postion method, so we set position method first then move location with dom.
                 */
                _this.domprocess
                    .setToolboxStackStyle(toolboxElement, _this.hightLevelZindex.top.toString())
                    // .then(this.domprocess.appendToBody)
                    .then(function (element) {
                    var position = _this.calculateToolboxPosition(canvas.offsetLeft, canvas.offsetTop, rect, element.offsetWidth, element.offsetHeight);
                    return _this.domprocess.setToolboxPositionStyle(element, position.left, position.top);
                })
                    .then(function (element) {
                    _this.showToolbox = true;
                });
            }
        };
        this.canvasContextmenuListener = function () {
            _this.isOpenChange.emit(false);
        };
        this.closeScreenshot = function () {
            _this.domprocess.remove(_this.interactiveCanvas);
            _this.showToolbox = false;
        };
        this.resizeCanvas = function () {
            if (!_this.interactiveCanvas) {
                return;
            }
            var elementSelector = _this.getElementSelector();
            var boudingClientRect = elementSelector[0].getBoundingClientRect();
            var width = boudingClientRect.width;
            var height = boudingClientRect.height;
            var offset = elementSelector.offset();
            var left = offset.left;
            var top = offset.top;
            _this.interactiveCanvas.width = width;
            _this.interactiveCanvas.height = height;
            _this.domprocess
                .setCanvasStyle(_this.interactiveCanvas, left, top, _this.colors.gray, _this.hightLevelZindex.second.toString())
                .then(function () { return _this.showToolbox = false; });
        };
    }
    ScreenshotComponent.prototype.ngOnInit = function () {
        var _this = this;
        if (!this.toolboxOptions) {
            this.toolboxOptions = {
                filename: this.defaultOptions.filename,
                cancelText: this.defaultOptions.cancelText,
                downloadText: this.defaultOptions.downloadText
            };
        }
        this.api.emit({
            cancel: this.cancel,
            download: this.download,
            downloadFull: this.downloadFull,
            toPng: this.toPng
        });
        window.onresize = function () {
            _this.resizeCanvas();
        };
    };
    ScreenshotComponent.prototype.ngOnChanges = function (item) {
        var isOpen = item.isOpen, toolboxOptions = item.toolboxOptions;
        switch (isOpen.currentValue) {
            case true:
                this.openScreenshot();
                break;
            case false:
                this.closeScreenshot();
                break;
            default:
                this.closeScreenshot();
                break;
        }
        if (toolboxOptions) {
            this.cancelText = toolboxOptions.cancelText ? toolboxOptions.cancelText : this.cancelText;
            this.downloadText = toolboxOptions.downloadText ? toolboxOptions.downloadText : this.downloadText;
            this.filename = toolboxOptions.filename ? toolboxOptions.filename : this.filename;
        }
    };
    ScreenshotComponent.prototype.openScreenshot = function () {
        var _this = this;
        var elementSelector = this.getElementSelector();
        var boudingClientRect = elementSelector[0].getBoundingClientRect();
        var width = boudingClientRect.width;
        var height = boudingClientRect.height;
        var offset = elementSelector.offset();
        var left = offset.left;
        var top = offset.top;
        this.setHightLevelZindex();
        this.domprocess
            .createCanvas(width, height)
            .then(function (canvas) {
            return _this.domprocess.setCanvasStyle(canvas, left, top, _this.colors.gray, _this.hightLevelZindex.second.toString());
        })
            .then(this.domprocess.appendToBody)
            .then(function (canvas) {
            return _this.domprocess.listenInteractiveCanvas(canvas, _this.colors.lightGray, _this.canvasMouseupListener, _this.canvasMousedownListener, _this.canvasContextmenuListener);
        })
            .then(function (canvas) { return (_this.interactiveCanvas = canvas); });
    };
    ScreenshotComponent.ctorParameters = function () { return [
        { type: Colors, decorators: [{ type: Inject, args: [forwardRef(function () { return Colors; }),] }] },
        { type: HightLevelZindex, decorators: [{ type: Inject, args: [forwardRef(function () { return HightLevelZindex; }),] }] },
        { type: ToolboxDefaultOptions, decorators: [{ type: Inject, args: [forwardRef(function () { return ToolboxDefaultOptions; }),] }] },
        { type: DOMProcess, decorators: [{ type: Inject, args: [forwardRef(function () { return DOMProcess; }),] }] }
    ]; };
    __decorate([
        ViewChild('container', { static: false }),
        __metadata("design:type", ElementRef)
    ], ScreenshotComponent.prototype, "container", void 0);
    __decorate([
        Input('target'),
        __metadata("design:type", String)
    ], ScreenshotComponent.prototype, "target", void 0);
    __decorate([
        Input('isOpen'),
        __metadata("design:type", Boolean)
    ], ScreenshotComponent.prototype, "isOpen", void 0);
    __decorate([
        Input('toolboxOptions'),
        __metadata("design:type", Object)
    ], ScreenshotComponent.prototype, "toolboxOptions", void 0);
    __decorate([
        Output('isOpenChange'),
        __metadata("design:type", Object)
    ], ScreenshotComponent.prototype, "isOpenChange", void 0);
    __decorate([
        Output('apiInitialized'),
        __metadata("design:type", Object)
    ], ScreenshotComponent.prototype, "api", void 0);
    ScreenshotComponent = __decorate([
        Component({
            selector: 'ng2-screenshot',
            template: '<div #container><ng-content></ng-content></div>'
        }),
        __param(0, Inject(forwardRef(function () { return Colors; }))),
        __param(1, Inject(forwardRef(function () { return HightLevelZindex; }))),
        __param(2, Inject(forwardRef(function () { return ToolboxDefaultOptions; }))),
        __param(3, Inject(forwardRef(function () { return DOMProcess; }))),
        __metadata("design:paramtypes", [Colors,
            HightLevelZindex,
            ToolboxDefaultOptions,
            DOMProcess])
    ], ScreenshotComponent);
    return ScreenshotComponent;
}());

/**
 * Custom template of screenshot toolbox, connent with screenshot
 */
var ScreenshotToolboxComponent = /** @class */ (function () {
    function ScreenshotToolboxComponent(parent) {
        this.parent = parent;
        this.hasContent = false;
        // const template = `<div class="screenshot-toolbox">${el.nativeElement.children().html()}</div>`;
        // renderer.selectRootElement(template);
        // el.nativeElement.remove();
    }
    ScreenshotToolboxComponent.prototype.cancel = function () {
        this.parent.cancel();
    };
    ScreenshotToolboxComponent.prototype.download = function () {
        this.parent.download();
    };
    ScreenshotToolboxComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        window.setTimeout(function () {
            _this.hasContent = _this.wrapper.nativeElement.children.length > 0;
        });
    };
    ScreenshotToolboxComponent.ctorParameters = function () { return [
        { type: ScreenshotComponent, decorators: [{ type: Inject, args: [ScreenshotComponent,] }] }
    ]; };
    __decorate([
        ViewChild('wrapper', { static: false }),
        __metadata("design:type", ElementRef)
    ], ScreenshotToolboxComponent.prototype, "wrapper", void 0);
    ScreenshotToolboxComponent = __decorate([
        Component({
            selector: 'ng2-screenshot-toolbox',
            template: "\n        <div class=\"screenshot-toolbox\" [hidden]=\"!parent.showToolbox\">\n            <div #wrapper>\n                <ng-content></ng-content>\n            </div>\n            <div *ngIf=\"!hasContent\">\n                <button class=\"btn\" type=\"button\" (click)=\"cancel()\">\n                    Cancel\n                </button>\n                <button class=\"btn\" type=\"button\" (click)=\"download()\">\n                    Download\n                </button>\n            </div>\n        </div>\n    ",
            styles: ["/*! Angular Screenshot - v0.1.0 - http://weihanchen.github.io/ng2-screenshot - (c) 2017 weihanchen - MIT */.screenshot-toolbox{width:100%}.screenshot-toolbox button{margin:.2em}.screenshot-toolbox .btn{position:relative;padding:.2em .4em;overflow:hidden;border-width:0;outline:0;border-radius:.2em;box-shadow:0 .1em .2em #4f4f4f;background-color:#e6e3e3;color:#4f4f4f;-webkit-transition:background-color .3s;transition:background-color .3s}.screenshot-toolbox .btn:focus,.screenshot-toolbox .btn:hover{background:#cdcccc}.screenshot-toolbox .btn>*{position:relative}.screenshot-toolbox .btn:before{content:\"\";position:absolute;top:50%;left:50%;display:block;width:0;padding-top:0;border-radius:100%;background-color:rgba(205,204,204,.3);-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.screenshot-toolbox .btn:active:before{width:120%;padding-top:120%;-webkit-transition:width .2s ease-out,padding-top .2s ease-out;transition:width .2s ease-out,padding-top .2s ease-out}.screenshot-toolbox .btn-navy{background-color:#1d9e74}.screenshot-toolbox .btn-navy:focus,.screenshot-toolbox .btn-navy:hover{background-color:#138661}.screenshot-toolbox-custom{visibility:hidden}"]
        }),
        __param(0, Inject(ScreenshotComponent)),
        __metadata("design:paramtypes", [ScreenshotComponent])
    ], ScreenshotToolboxComponent);
    return ScreenshotToolboxComponent;
}());

var Ng2ScreenshotModule = /** @class */ (function () {
    function Ng2ScreenshotModule() {
    }
    Ng2ScreenshotModule = __decorate([
        NgModule({
            imports: [CommonModule],
            declarations: [ScreenshotComponent, ScreenshotToolboxComponent],
            exports: [ScreenshotComponent, ScreenshotToolboxComponent],
            providers: [Colors, HightLevelZindex, ToolboxDefaultOptions, DOMProcess, ScreenshotComponent]
        })
    ], Ng2ScreenshotModule);
    return Ng2ScreenshotModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { Ng2ScreenshotModule, ScreenshotComponent as ɵa, ToolboxDefaultOptions as ɵb, Colors as ɵc, HightLevelZindex as ɵd, DOMProcess as ɵe, ScreenshotToolboxComponent as ɵf };
//# sourceMappingURL=ng2-screenshot.js.map
