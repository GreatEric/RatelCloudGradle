import { __decorate, __awaiter, __metadata, __param } from 'tslib';
import { CommonModule } from '@angular/common';
import { Injectable, EventEmitter, Inject, forwardRef, ViewChild, ElementRef, Input, Output, Component, NgModule } from '@angular/core';
import domtoimage from 'dom-to-image';
import * as jq from 'jquery';

let ToolboxDefaultOptions = class ToolboxDefaultOptions {
    constructor() {
        this.filename = 'screenshot.png';
        this.cancelText = 'Cancel';
        this.downloadText = 'Download';
    }
};
ToolboxDefaultOptions = __decorate([
    Injectable()
], ToolboxDefaultOptions);
let Colors = class Colors {
    constructor() {
        this.gray = '#898b89';
        this.lightGray = '#e6e3e3';
    }
};
Colors = __decorate([
    Injectable()
], Colors);
let HightLevelZindex = class HightLevelZindex {
    constructor() {
        this.top = 1;
        this.second = 0;
    }
};
HightLevelZindex = __decorate([
    Injectable()
], HightLevelZindex);

'use strict';
let DOMProcess = class DOMProcess {
    constructor() {
        this.domURL = window.URL;
        this.imageType = 'image/png';
    }
    appendToBody(element) {
        return __awaiter(this, void 0, void 0, function* () {
            document.body.appendChild(element);
            return element;
        });
    }
    canvasToImage(canvas) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = canvas.toDataURL(this.imageType);
            return yield this.dataUrlToImage(url);
        });
    }
    clearCanvasRect(canvas) {
        const context = canvas.getContext('2d');
        context.clearRect(0, 0, canvas.width, canvas.height);
    }
    dataUrlToImage(url) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => {
                    resolve(image);
                };
                image.onerror = reject;
                image.src = url;
            });
        });
    }
    clipImageToCanvas(image, clipStartX, clipStartY, clipWidth, clipHeight) {
        return __awaiter(this, void 0, void 0, function* () {
            const canvas = yield this.createCanvas(Math.abs(clipWidth), Math.abs(clipHeight));
            const context = canvas.getContext('2d');
            context.drawImage(image, clipStartX, clipStartY, clipWidth, clipHeight, 0, 0, canvas.width, canvas.height);
            this.remove(image);
            return canvas;
        });
    }
    createCanvas(width, height) {
        return __awaiter(this, void 0, void 0, function* () {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            return canvas;
        });
    }
    downloadByUrl(url, filename) {
        const downloadLink = document.createElement('a');
        downloadLink.href = url;
        downloadLink.download = filename;
        downloadLink.target = '_blank';
        downloadLink.click();
        downloadLink.remove();
        this.domURL.revokeObjectURL(url);
    }
    downloadCanvas(canvas, filename) {
        return __awaiter(this, void 0, void 0, function* () {
            const downloadUrl = canvas.toDataURL(this.imageType);
            this.downloadByUrl(downloadUrl, filename);
            return canvas;
        });
    }
    getStyle(element, property) {
        const styles = window.getComputedStyle(element);
        return styles[property];
    }
    remove(element) {
        if (element) {
            element.remove();
        }
        element = null;
    }
    isTransparent(element) {
        const backgroundColor = window.getComputedStyle(element).backgroundColor;
        return backgroundColor === 'transparent' || backgroundColor === '' || backgroundColor === 'rgba(0, 0, 0, 0)';
    }
    listenInteractiveCanvas(canvas, rectBackground, mouseupListener, mousedownListener, contextmenuListener) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = canvas.getContext('2d');
            const rect = {
                startX: 0,
                startY: 0,
                w: 0,
                h: 0
            };
            let dragging = false;
            const draw = () => {
                context.beginPath();
                context.fillStyle = rectBackground;
                context.fillRect(rect.startX, rect.startY, rect.w, rect.h);
                context.closePath();
            };
            const mousedown = (e) => {
                context.clearRect(0, 0, canvas.width, canvas.height);
                rect.startX = e.pageX - canvas.offsetLeft;
                rect.startY = e.pageY - canvas.offsetTop;
                mousedownListener(rect);
                rect.w = 0;
                rect.h = 0;
                dragging = true;
            };
            const mousemove = (e) => {
                if (dragging) {
                    rect.w = e.pageX - canvas.offsetLeft - rect.startX;
                    rect.h = e.pageY - canvas.offsetTop - rect.startY;
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    draw();
                }
            };
            const mouseup = () => {
                dragging = false;
                mouseupListener(canvas, rect);
            };
            const contextmenu = (e) => {
                contextmenuListener();
                e.preventDefault();
                return false;
            };
            const touchStart = (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.pageX,
                    clientY: touch.pageY
                });
                canvas.dispatchEvent(mouseEvent);
            };
            const touched = () => {
                const mouseEvent = new MouseEvent('mouseup', {});
                canvas.dispatchEvent(mouseEvent);
            };
            const touchMove = (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.pageX,
                    clientY: touch.pageY
                });
                canvas.dispatchEvent(mouseEvent);
            };
            canvas.addEventListener('mousedown', mousedown, false);
            canvas.addEventListener('mouseup', mouseup, false);
            canvas.addEventListener('mousemove', mousemove, false);
            canvas.addEventListener('touchstart', touchStart, false);
            canvas.addEventListener('touchend', touched, false);
            canvas.addEventListener('touchmove', touchMove, false);
            canvas.addEventListener('contextmenu', contextmenu, false);
            document.body.addEventListener('touchmove', event => event.preventDefault(), false);
            return canvas;
        });
    }
    setCanvasStyle(canvas, left, top, background, zIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            canvas.style.cursor = 'crosshair';
            canvas.style.position = 'absolute';
            canvas.style.left = left + 'px';
            canvas.style.top = top + 'px';
            canvas.style.background = background;
            canvas.style.zIndex = zIndex;
            canvas.style.opacity = '0.5';
            return canvas;
        });
    }
    setToolboxPositionStyle(toolboxElement, left, top) {
        return __awaiter(this, void 0, void 0, function* () {
            toolboxElement.style.left = left + 'px';
            toolboxElement.style.top = top + 'px';
            return toolboxElement;
        });
    }
    setToolboxStackStyle(toolboxElement, zIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            toolboxElement.style.position = 'absolute';
            toolboxElement.style.zIndex = zIndex;
            return toolboxElement;
        });
    }
};
DOMProcess = __decorate([
    Injectable(),
    __metadata("design:paramtypes", [])
], DOMProcess);

const $ = jq;
/**
 * Capture dom setion with indicate element
 */
let ScreenshotComponent = class ScreenshotComponent {
    constructor(colors, hightLevelZindex, defaultOptions, domprocess) {
        this.colors = colors;
        this.hightLevelZindex = hightLevelZindex;
        this.defaultOptions = defaultOptions;
        this.domprocess = domprocess;
        this.isOpenChange = new EventEmitter();
        this.api = new EventEmitter();
        this.showToolbox = false;
        this.cancelText = 'Cancel';
        this.downloadText = 'Download';
        this.filename = 'screenshot.png';
        this.toolboxMargin = 5;
        this.calculateToolboxPosition = (offsetLeft, offsetTop, rect, toolboxWidth, toolboxHeight) => {
            let left = offsetLeft + rect.startX + rect.w;
            let top = offsetTop + rect.startY + rect.h;
            if (rect.w >= 0) {
                left -= toolboxWidth;
            }
            if (rect.h >= 0) {
                top += this.toolboxMargin;
            }
            else {
                top = top - toolboxHeight - this.toolboxMargin;
            }
            return {
                left,
                top
            };
        };
        this.cancel = () => {
            this.showToolbox = false;
            this.domprocess.clearCanvasRect(this.interactiveCanvas);
        };
        this.download = () => {
            this.isOpenChange.emit(false);
            window.setTimeout(() => {
                const elementSelector = this.getElementSelector();
                const element = elementSelector[0];
                const options = this.getOptions(element);
                domtoimage
                    .toPng(element, options)
                    .then(this.domprocess.dataUrlToImage)
                    .then((image) => {
                    this.domprocess.remove(image);
                    return this.domprocess.clipImageToCanvas(image, this.rect.startX, this.rect.startY, this.rect.w, this.rect.h);
                })
                    .then((canvas) => this.domprocess.downloadCanvas(canvas, this.toolboxOptions.filename))
                    .then(this.domprocess.remove)
                    .catch((error) => console.error(error));
            });
        };
        this.downloadFull = () => {
            this.isOpenChange.emit(false);
            window.setTimeout(() => {
                const elementSelector = this.getElementSelector();
                const element = elementSelector[0];
                const options = this.getOptions(element);
                domtoimage
                    .toPng(element, options)
                    .then((imageUrl) => this.domprocess.downloadByUrl(imageUrl, this.toolboxOptions.filename))
                    .catch((error) => console.error(error));
            });
        };
        this.findMaxZindex = () => {
            let zMax = 0;
            $('body *').each(function () {
                const zIndexStr = $(this).css('zIndex');
                const zIndex = parseInt(zIndexStr, 10);
                if (zIndex && zIndex > zMax) {
                    zMax = zIndex;
                }
            });
            return zMax;
        };
        this.getElementSelector = () => {
            return this.target
                ? $(this.target)
                : $(this.container.nativeElement).filter((index, element) => {
                    const elementName = element.tagName.toLowerCase();
                    return elementName !== 'screenshot-toolbox';
                });
        };
        this.getOptions = (element) => {
            const boudingClientRect = element.getBoundingClientRect();
            let options = {
                width: boudingClientRect.width,
                height: boudingClientRect.height
            };
            if (this.domprocess.isTransparent(element)) {
                const parentBackgroundColor = this.domprocess.getStyle(element, 'backgroundColor');
                options = Object.assign({}, options, { bgcolor: parentBackgroundColor });
            }
            return options;
        };
        this.setHightLevelZindex = () => {
            const maxZindex = this.findMaxZindex();
            this.hightLevelZindex.second = maxZindex + 1;
            this.hightLevelZindex.top = this.hightLevelZindex.second + 1;
        };
        this.toPng = (callback) => new Promise((resolve, reject) => {
            this.isOpenChange.emit(false);
            window.setTimeout(() => {
                const elementSelector = this.getElementSelector();
                const element = elementSelector[0];
                const options = this.getOptions(element);
                return domtoimage
                    .toPng(element, options)
                    .then(this.domprocess.dataUrlToImage)
                    .then((image) => {
                    this.domprocess.remove(image);
                    return this.domprocess.clipImageToCanvas(image, this.rect.startX, this.rect.startY, this.rect.w, this.rect.h);
                })
                    .then((canvas) => {
                    const url = canvas.toDataURL('image/png');
                    if (callback) {
                        callback(url);
                    }
                    resolve(url);
                })
                    .catch((error) => {
                    console.error(error);
                    reject(error);
                });
            });
        });
        this.canvasMousedownListener = () => {
            this.showToolbox = false;
        };
        this.canvasMouseupListener = (canvas, rect) => {
            if (rect.w !== 0 && rect.h !== 0) {
                // this.showToolbox = false;
                this.rect = rect;
                const toolbox = $(this.container.nativeElement).find('ng2-screenshot-toolbox');
                console.log(toolbox.outerWidth());
                // console.log(toolbox.width())
                // // const toolbox = $('ng2-screenshot-toolbox');
                const toolboxElement = toolbox.get(0);
                console.log(toolboxElement.clientWidth);
                console.log(this.hightLevelZindex);
                /**
                 * toolbox position setting
                 * because read elememt's width sould indicated postion method, so we set position method first then move location with dom.
                 */
                this.domprocess
                    .setToolboxStackStyle(toolboxElement, this.hightLevelZindex.top.toString())
                    // .then(this.domprocess.appendToBody)
                    .then(element => {
                    const position = this.calculateToolboxPosition(canvas.offsetLeft, canvas.offsetTop, rect, element.offsetWidth, element.offsetHeight);
                    return this.domprocess.setToolboxPositionStyle(element, position.left, position.top);
                })
                    .then(element => {
                    this.showToolbox = true;
                });
            }
        };
        this.canvasContextmenuListener = () => {
            this.isOpenChange.emit(false);
        };
        this.closeScreenshot = () => {
            this.domprocess.remove(this.interactiveCanvas);
            this.showToolbox = false;
        };
        this.resizeCanvas = () => {
            if (!this.interactiveCanvas) {
                return;
            }
            const elementSelector = this.getElementSelector();
            const boudingClientRect = elementSelector[0].getBoundingClientRect();
            const width = boudingClientRect.width;
            const height = boudingClientRect.height;
            const offset = elementSelector.offset();
            const left = offset.left;
            const top = offset.top;
            this.interactiveCanvas.width = width;
            this.interactiveCanvas.height = height;
            this.domprocess
                .setCanvasStyle(this.interactiveCanvas, left, top, this.colors.gray, this.hightLevelZindex.second.toString())
                .then(() => this.showToolbox = false);
        };
    }
    ngOnInit() {
        if (!this.toolboxOptions) {
            this.toolboxOptions = {
                filename: this.defaultOptions.filename,
                cancelText: this.defaultOptions.cancelText,
                downloadText: this.defaultOptions.downloadText
            };
        }
        this.api.emit({
            cancel: this.cancel,
            download: this.download,
            downloadFull: this.downloadFull,
            toPng: this.toPng
        });
        window.onresize = () => {
            this.resizeCanvas();
        };
    }
    ngOnChanges(item) {
        const { isOpen, toolboxOptions } = item;
        switch (isOpen.currentValue) {
            case true:
                this.openScreenshot();
                break;
            case false:
                this.closeScreenshot();
                break;
            default:
                this.closeScreenshot();
                break;
        }
        if (toolboxOptions) {
            this.cancelText = toolboxOptions.cancelText ? toolboxOptions.cancelText : this.cancelText;
            this.downloadText = toolboxOptions.downloadText ? toolboxOptions.downloadText : this.downloadText;
            this.filename = toolboxOptions.filename ? toolboxOptions.filename : this.filename;
        }
    }
    openScreenshot() {
        const elementSelector = this.getElementSelector();
        const boudingClientRect = elementSelector[0].getBoundingClientRect();
        const width = boudingClientRect.width;
        const height = boudingClientRect.height;
        const offset = elementSelector.offset();
        const left = offset.left;
        const top = offset.top;
        this.setHightLevelZindex();
        this.domprocess
            .createCanvas(width, height)
            .then(canvas => this.domprocess.setCanvasStyle(canvas, left, top, this.colors.gray, this.hightLevelZindex.second.toString()))
            .then(this.domprocess.appendToBody)
            .then(canvas => this.domprocess.listenInteractiveCanvas(canvas, this.colors.lightGray, this.canvasMouseupListener, this.canvasMousedownListener, this.canvasContextmenuListener))
            .then(canvas => (this.interactiveCanvas = canvas));
    }
};
ScreenshotComponent.ctorParameters = () => [
    { type: Colors, decorators: [{ type: Inject, args: [forwardRef(() => Colors),] }] },
    { type: HightLevelZindex, decorators: [{ type: Inject, args: [forwardRef(() => HightLevelZindex),] }] },
    { type: ToolboxDefaultOptions, decorators: [{ type: Inject, args: [forwardRef(() => ToolboxDefaultOptions),] }] },
    { type: DOMProcess, decorators: [{ type: Inject, args: [forwardRef(() => DOMProcess),] }] }
];
__decorate([
    ViewChild('container', { static: false }),
    __metadata("design:type", ElementRef)
], ScreenshotComponent.prototype, "container", void 0);
__decorate([
    Input('target'),
    __metadata("design:type", String)
], ScreenshotComponent.prototype, "target", void 0);
__decorate([
    Input('isOpen'),
    __metadata("design:type", Boolean)
], ScreenshotComponent.prototype, "isOpen", void 0);
__decorate([
    Input('toolboxOptions'),
    __metadata("design:type", Object)
], ScreenshotComponent.prototype, "toolboxOptions", void 0);
__decorate([
    Output('isOpenChange'),
    __metadata("design:type", Object)
], ScreenshotComponent.prototype, "isOpenChange", void 0);
__decorate([
    Output('apiInitialized'),
    __metadata("design:type", Object)
], ScreenshotComponent.prototype, "api", void 0);
ScreenshotComponent = __decorate([
    Component({
        selector: 'ng2-screenshot',
        template: '<div #container><ng-content></ng-content></div>'
    }),
    __param(0, Inject(forwardRef(() => Colors))),
    __param(1, Inject(forwardRef(() => HightLevelZindex))),
    __param(2, Inject(forwardRef(() => ToolboxDefaultOptions))),
    __param(3, Inject(forwardRef(() => DOMProcess))),
    __metadata("design:paramtypes", [Colors,
        HightLevelZindex,
        ToolboxDefaultOptions,
        DOMProcess])
], ScreenshotComponent);

/**
 * Custom template of screenshot toolbox, connent with screenshot
 */
let ScreenshotToolboxComponent = class ScreenshotToolboxComponent {
    constructor(parent) {
        this.parent = parent;
        this.hasContent = false;
        // const template = `<div class="screenshot-toolbox">${el.nativeElement.children().html()}</div>`;
        // renderer.selectRootElement(template);
        // el.nativeElement.remove();
    }
    cancel() {
        this.parent.cancel();
    }
    download() {
        this.parent.download();
    }
    ngAfterViewInit() {
        window.setTimeout(() => {
            this.hasContent = this.wrapper.nativeElement.children.length > 0;
        });
    }
};
ScreenshotToolboxComponent.ctorParameters = () => [
    { type: ScreenshotComponent, decorators: [{ type: Inject, args: [ScreenshotComponent,] }] }
];
__decorate([
    ViewChild('wrapper', { static: false }),
    __metadata("design:type", ElementRef)
], ScreenshotToolboxComponent.prototype, "wrapper", void 0);
ScreenshotToolboxComponent = __decorate([
    Component({
        selector: 'ng2-screenshot-toolbox',
        template: `
        <div class="screenshot-toolbox" [hidden]="!parent.showToolbox">
            <div #wrapper>
                <ng-content></ng-content>
            </div>
            <div *ngIf="!hasContent">
                <button class="btn" type="button" (click)="cancel()">
                    Cancel
                </button>
                <button class="btn" type="button" (click)="download()">
                    Download
                </button>
            </div>
        </div>
    `,
        styles: ["/*! Angular Screenshot - v0.1.0 - http://weihanchen.github.io/ng2-screenshot - (c) 2017 weihanchen - MIT */.screenshot-toolbox{width:100%}.screenshot-toolbox button{margin:.2em}.screenshot-toolbox .btn{position:relative;padding:.2em .4em;overflow:hidden;border-width:0;outline:0;border-radius:.2em;box-shadow:0 .1em .2em #4f4f4f;background-color:#e6e3e3;color:#4f4f4f;-webkit-transition:background-color .3s;transition:background-color .3s}.screenshot-toolbox .btn:focus,.screenshot-toolbox .btn:hover{background:#cdcccc}.screenshot-toolbox .btn>*{position:relative}.screenshot-toolbox .btn:before{content:\"\";position:absolute;top:50%;left:50%;display:block;width:0;padding-top:0;border-radius:100%;background-color:rgba(205,204,204,.3);-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%)}.screenshot-toolbox .btn:active:before{width:120%;padding-top:120%;-webkit-transition:width .2s ease-out,padding-top .2s ease-out;transition:width .2s ease-out,padding-top .2s ease-out}.screenshot-toolbox .btn-navy{background-color:#1d9e74}.screenshot-toolbox .btn-navy:focus,.screenshot-toolbox .btn-navy:hover{background-color:#138661}.screenshot-toolbox-custom{visibility:hidden}"]
    }),
    __param(0, Inject(ScreenshotComponent)),
    __metadata("design:paramtypes", [ScreenshotComponent])
], ScreenshotToolboxComponent);

let Ng2ScreenshotModule = class Ng2ScreenshotModule {
};
Ng2ScreenshotModule = __decorate([
    NgModule({
        imports: [CommonModule],
        declarations: [ScreenshotComponent, ScreenshotToolboxComponent],
        exports: [ScreenshotComponent, ScreenshotToolboxComponent],
        providers: [Colors, HightLevelZindex, ToolboxDefaultOptions, DOMProcess, ScreenshotComponent]
    })
], Ng2ScreenshotModule);

/**
 * Generated bundle index. Do not edit.
 */

export { Ng2ScreenshotModule, ScreenshotComponent as ɵa, ToolboxDefaultOptions as ɵb, Colors as ɵc, HightLevelZindex as ɵd, DOMProcess as ɵe, ScreenshotToolboxComponent as ɵf };
//# sourceMappingURL=ng2-screenshot.js.map
